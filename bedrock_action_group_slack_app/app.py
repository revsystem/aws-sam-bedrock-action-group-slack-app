import ast
import json
import logging
import os
import re

import boto3
from botocore.config import Config
from botocore.exceptions import ClientError
from slack_bolt import App
from slack_bolt.adapter.aws_lambda import SlackRequestHandler

SlackRequestHandler.clear_all_log_handlers()
logging.basicConfig(
    format="%(asctime)s [%(levelname)s] %(message)s",
    level=logging.INFO
)

logger = logging.getLogger(__name__)


class SecretsManager:
    """
    Class to retrieve secrets from Secrets Manager

    Attributes:
        secret_name (str): The name of the secret
        region_name (str): The name of the region
        client (boto3.client): The client for Secrets Manager
    """

    def __init__(self, secret_name, region_name):
        self.secret_name = secret_name
        self.region_name = region_name
        self.client = boto3.client(
            service_name='secretsmanager',
            region_name=region_name
        )

    def get_secret(self, key):
        """
        Retrieves the value of a secret based on the provided key.

        Args:
            key (str): The key of the secret to retrieve.

        Returns:
            str: The value of the secret.

        Raises:
            ClientError: If there is an error retrieving the secret.
        """
        try:
            get_secret_value_response = self.client.get_secret_value(
                SecretId=self.secret_name
            )
        except ClientError as e:
            raise e

        secret_data = get_secret_value_response['SecretString']
        secret = ast.literal_eval(secret_data)

        return secret[key]


secrets_manager = SecretsManager(
    secret_name=os.environ.get("SECRET_NAME"),
    region_name=os.environ.get("REGION_NAME")
)

app = App(
    signing_secret=secrets_manager.get_secret("SlackSigningSecret"),
    token=secrets_manager.get_secret("SlackBotToken"),
    process_before_response=True,
)


def invoke_agent(agent_id, agent_alias_id, session_id, prompt):
    """
    Invokes the agent with the given parameters and returns the completion or
    references.

    Args:
        agent_id (str): The ID of the agent.
        agent_alias_id (str): The ID of the agent alias.
        session_id (str): The ID of the session.
        prompt (str): The prompt to send to the agent.

    Returns:
        str: The completion or references generated by the agent.
    """
    enable_trace = False

    try:
        client = boto3.client(
                service_name='bedrock-agent-runtime',
                region_name="us-east-1",
                config=Config(
                    read_timeout=180,
                )
            )

        response = client.invoke_agent(
                inputText=prompt,
                agentId=agent_id,
                agentAliasId=agent_alias_id,
                sessionId=session_id,
                enableTrace=enable_trace,
        )

        completion = ""

        for event in response.get("completion"):
            completion += event['chunk']['bytes'].decode("utf-8")

            if 'trace' in event:
                logger.info(json.dumps(event['trace'], indent=2, ensure_ascii=False))

    except ClientError as e:
        logger.error("Couldn't invoke agent. %s", e)
        raise

    return completion


def handle_app_mentions(event, say):
    """
    Handle app mentions in Slack.

    Args:
        event (dict): The event data containing information about the mention.
        say (function): The function used to send a message in Slack.

    Returns:
        None
    """
    agent_id = secrets_manager.get_secret("BedrockAgentId")
    agent_alias_id = secrets_manager.get_secret("BedrockAgentAliasId")

    thread_ts = event["ts"]
    userid = event["user"]
    prompt = re.sub("<@.*>", "", event["text"])

    say("\n\nお待ちください...", thread_ts=thread_ts)
    if "thread_ts" in event:
        thread_ts = event["thread_ts"]

    print(f"agent_id: {agent_id}")
    print(f"agent_alias_id: {agent_alias_id}")
    response = invoke_agent(agent_id, agent_alias_id, thread_ts, prompt)
    say(f"<@{userid}> {response}", thread_ts=thread_ts)


def respond_to_slack_within_3_seconds(ack):
    """
    Responds to a Slack message within 3 seconds.

    Parameters:
    - ack: A function to acknowledge the Slack message.

    Returns:
    None
    """
    ack()


app.event("app_mention")(
    ack=respond_to_slack_within_3_seconds,
    lazy=[handle_app_mentions]
)


def lambda_handler(event, context):
    """
    Lambda function handler for processing Slack events.

    Args:
        event (dict): The event data passed to the Lambda function.
        context (object): The runtime information of the Lambda function.

    Returns:
        dict: The response data to be returned by the Lambda function.
    """
    print(event)

    retry_counts = event.get("multiValueHeaders", {}).get("X-Slack-Retry-Num", [0])

    if retry_counts[0] != 0:
        logging.info("Skip slack retrying(%s).", retry_counts)
        return {}

    slack_handler = SlackRequestHandler(app=app)
    return slack_handler.handle(event, context)
